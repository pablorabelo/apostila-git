---
title: "Serviços Web para Projetos Git"
author: "PET Estatística UFPR"
output:
  pdf_document:
    highlight: default
    toc: true
    toc_depth: 2
    keep_tex: true
---

```{r, include=FALSE}
library(knitr)
opts_chunk$set(comment=NA)
```

# Serviços Web para Git #

No capítulo anterior vimos como configurar um repositório remoto em um
servidor. Esse procedimento possibilita trabalho em equipe visto que
todos com acesso à servidora, então podem clonar, subir ramos, etc.
Apesar do servidor centralizar as contribuições de todos os usuários,
estes terão que se comunicar e manter os compromissos sobre o projeto em
de outra forma, por email direto, lista de email, lista de
discussão. Para que um desenvolvedor saiba o que os outros fizeram, ele
terá que periodicamente dar `fetch`, navegar no histórico, ver *diffs*,
etc.

O Git tem muitos serviços web voltados justamente para ter um local que
centralize o projeto bem como ofereça recursos administrativos e
colaborativos. Esses serviços possuem contas *free* etc...

O objetivo desse capítulo é apresentar os serviços web para repositórios
Git, descrever suas principais características, indicar como criar e
configurar uma conta ligada a um repositório local. Além disso, o
*workflow* básico que considera servições web será descrito, enfatizando
as funcinalides desses serviçõs voltados à colaboração.

## GitHub ##

![](./images/github-octocat.png)

O [GitHub] é um serviço Web para hospedagem, gestão e compartilhamento
de repositórios Git que oferece recursos para desenvolvimento e
colaboração. A principal slogam do GitHub é: *"Build software better,
together."* que justamente enfatiza o compromisso principal que é dar
suporte ao desenvolvimento colaborativo.

O GitHub foi fundado em 8 de Fevereiro de 2008, em São Francisco, por
quatro pessoas: Tom Preston-Werner, Chris Wanstrath, PJ Hyett e Scott
Chacon. Antes de terminar 2015, o GitHub já ultrapassou a marca de 10
milhões de usuários. De acordo com o <http://githut.info/>, no quarto
trimestre de 2014 haviam 22 milhões de repositórios. A linguagem
`JavaScript` teve o maior número de repositórios ativos (>320 mil) e
total de *pushes* enquanto que a linguagem `R` foi a com maior número de
novas cópias por repositório (6.45).

Diferente da forma tradicional de usar o Git, por linha de comando, que
fizemos até agora, o GitHub é um serviço web com interface gráfica
repleta de funções para o desenvolvimento e acompanhamento de um projeto
Git. Tais recursos vão desde administrar tarefas até a permitir a
colaboração de outras pessoas, até mesmo desconhecidos. Dentre os
principais recursos disponíveis, tem-se:

  * README: é um arquivo texto escrito em liguagem de marcação
    (Markdown, RST, Textile, Org, etc) que é renderizada para
    exibição. O README é a capa do seu repositório, ou seja, o conteúdo
    apresentado na *home* do projeto e serve para informar o visitante
    dos objetivos do repositório, seus desenvolvedores e pode conter
    instruções de instalação e colaboração.
  * Wiki: a Wiki de cada repositório serve para divulgação e
    documentação. Também é escrita em linguagem de marcação, tornando
    fácil e rápido a escrita pelo desenvolvedor e simples a leitura e a
    navegação pelo visitante. Como a Wiki é também um repositório Git,
    ela pode inclusive ser editada por meios dos recursos de edição do
    prórpio GitHub, além de versionada, claro. Com isso, não diferente
    do restante, a edição da Wiki também é colaborativa.
  * *Issues*: Por *issues* é que se faz a correção de bugs e agendamento
    de tarefas. Usuários criam *issues* para notificar um bug encontrado
    de forma que ele possa ser rapidamente corrigido. Criar *issues*
    também serve como ferramenta de admistração de tarefas nas quais os
    *issues* descrevem algo a ser feito e por quem.
  * *Milestones*: são pedras de milha, ou seja, marcam um ponto a ser
    alcançado. No GitHub, são usadas para descrever o que precisa ser
    desenvolvido para que ocorra uma mundança de versão e estabalecer um
    prazo para conclusão, por exemplo.
  * *Pull request* ou *merge request* (MR): é uma requisição de
    fusão. Os membros da equipe fazem suas contribuições em ramos de
    desenvolvimento e ao concluir pedem um MR pela interface. O
    responsável por avaliar o MR pode ver os *diffs* nos arquivos e
    fazer o merge direto pela interfaçe, de dentro do serviço sem
    precisar baixar o ramo, aplicar o merge e subí-lo.
  * *Fork*: é uma forma de se fazer uma cópia do projeto de alguém para
    livremente experimentar modificações sem afetar o projeto
    original. A cópia vem para a sua conta e funciona como qualquer
    outro repositório seu. A ideia do *fork* é dar liberdade de
    contribuição (não supervisionada) a qualquer pessoa interessada de
    modo que esta possa submeter as contribuições para a origem (por MR)
    ou até mesmo usar como ponto de partida para um projeto.

De acordo com [Klint Finley], *fork* e MR são o que tornam o GitHub tão
poderoso. Quando o mantenedor recebe um MR ele pode ver o perfil do
contribuidor onde estão listados todos os projetos no qual este deu
contribuição. Ao aceitar o MR, é acrescentado mais uma colaboração a
reputação do colaborador. Esse mecanísmo, então, beneficia as duas
partes.

Além dessas características chaves, o GitHub permite que você acompanhe
(*watch*) e favorite (*star*) repositórios. Também dá para seguir
pessoas e participar de organizações (grupo de usuários) que podem ter
repositórios próprios, ideal para projetos em equipe. O perfil de cada
usuário registra suas atividades e dentro de cada projeto pode-se
acompanhar as contribuições de cada colaborador. Em cada repositório
pode-se navegar pelo histórico de *commits*, filtrar por colaborador,
ver as modificações no código (*diffs*) comaprando *commits* e
*branches*.

O GitHub não hospeda apenas código fonte mas sim todo e qualquer arquivo
que você tenha sob versionamento. É possível hospedar dados, por
exemplo, em formato texto (csv), e disponibilizá-los por meio da URL
para download ou leitura direta. Para nós que somos usuários de R, essa
é uma característica que permite não só disponibilizar dados, mas também
coleções de funções que podem ser carregadas com um `source()`.

Com o plano *free* do GitHub, você pode ter inúmeros repositórios
públicos e inúmeros colaboradores, pode ter o *fork* de quantos
repositórios quiser e participar de quantas organizações precisar. Para
ter repositórios privados, o plano mais básico custa U$ 7 e dá direito a
5 repositórios. Existem outros planos individuais, e também planos
organizacionais, para todos os tamanhos de projeto e equipe. Além dessas
formas, pode-se ter o GitHub em um servidor próprio, o
[GitHub Interprise], que tem vantagens além das já mencionadas, no
entanto, tal como qualquer plano privado, tem seu custo.

É uma fonte de conhecimento onde você encontra *scripts* nas mais
diferentes linguagens de programação. Você pode livremente estudar o
código dos repositórios, ver como o código evoluiu *commit* após
*commit* e como um *bug* foi resolvido. Qualquer pessoa, mesmo sem
perfil no GitHub, pode clonar um repositório público. O GitHub reconhece
382 linguagens que compreendem as de programação (293: C++, Python, R,
JavaScript), as de *markup* (34: HTML, TeX, MarkDown), as de dados (40:
JSON, SQL, XML, csv) e aplica os realces (highlights) que facilitam a
leitura do código.

O GitHub é o serviço web para Git mais popular quanto ao número de
projetos hospedados. No entanto, existem serviços com as mesmas e até
com funcionalidades que o GiHub não oferece no plano básico. O GitLab e
o Bitbucket estão entre os 5 mais populares e permitem, por exemplo, ter
alguns repositórios privados com a conta *free*.

## GitLab ##

![](./images/gitlab-raccoon.jpg)

FIGURA O guaxinim (*raccoon* em inglês) é o macote do GitLab.

Assim como o GitHub, o [GitLab] é um serviço Web para repositórios
Git. O GitLab é um projeto *open source* desenvolvido em Ruby que deu
início em 2011 pelo Ucrâniano Dmitriy Zaporozhets. Em 2013, a Companhia
GitLab tinha 11 membros e mais de 10 mil organizações.

O GitLab, além de ser um serviço gratuíto (com planos extras)
colaboração, é também um programa que você pode instalar em servidor
local para ter seus repositórios na intraweb, se for o caso.

Como serviço web, o GitLab oferece basicamente todos os recursos do
GitHub e do BitBucket [^1]. No entanto, com uma conta gratuíta no
<http://gitlab.com> você pode ter, além dos repositórios públicos e
colaboradores, ilimitados repositórios privados sem pagar por nada. Isso
faz do GitLab.com o lugar certo para pequenas equipes com pouco recurso
ou que desenvolvem trabalhos sem fins lucrativos, como é o caso de
colaboração em código para análise de dados para publicação científica.

Atualmente existem mais de 69 mil projetos públicos e 5840 grupos
abertos no GitLab.com (https://gitlab.com/explore)

A versão paga do GitLab, a *Enterprise Edition* (EE), tem um preço
muitas vezes menor que a equivalente do GitHub.

A versão gratuíta do GitLab para servidores, a *Community Edition* (CE),
pode ser instalada em servidores Linux, Windows, máquinas vituais e
servidores na núvem, além de outras opções. Os serviços
<https://gitlab.c3sl.ufpr.br/explore> e <http://git.leg.ufpr.br/explore>
são o GitLab CE para servidores rodando no C3SL (Centro de Computação
Científica e Software Livre) e LEG (Laboratório de Estatística e
Geoinformação). Estes serviços dão suporte à colaboração em código
dentro dos departamentos de Informática e Estatística para alunos e
professores (C3SL) e para a equipe e colaboradores do LEG (LEG).

Em termos finaceiros, vale mais a pena pagar por um servidor na núvem da
[Digital Ocean] com o GitLab CE (U$ 5/mês) do que ter uma conta para
repositórios privados no GitHub (U$ 7/mes por 5 repositórios
privados). No entanto, conforme já mencionamos, pequenas equipes podem
ter repositórios privados na conta gratuíta do GitLab.com.

Além das características essenciais ou comuns aos demais serviços, como
*issues*, *fork*, *merge requests*, *wiki* e *snippets*, o
GitLab tem repositórios com 5 níveis de acesso (*owner*, *master*,
*developer*, *report* e *guess*); revisão comentada de código nos
*diffs*; permite importar repositórios de outros serviços; permite
adição de *web hooks*.

## Outros ##

<http://www.git-tower.com/blog/git-hosting-services-compared/>

# Criar um perfil #

Criar uma conta no Github é tão simples como uma conta de email ou de
rede social. Acesse o endereço <https://github.com/join> para preencher
seus dados pessoais e escolher um plano. Nenhum dos planos tem limitação
quanto ao número de repositórios ou colaboradores. O que muda é a
quantidade de reposiórios privados. No plano *free*, só são criados
repositórios públicos enquanto que nos planos pagos, o menor deles
permite 5 repositórios privados por um custo de U$ 5 por mês. Acesse
<https://github.com/pricing> para mais detalhes.

Ao preencher o formulário de criação de conta, você receberá um email
com uma ulr de ativação. Se optar por planos pagos, terá informar número
do cartão de crédito para que seja feito o pagamento mensalmente.

Para criar uma conta gratuíta no GitLab, acesse
<https://gitlab.com/users/sign_in>. Os serviços GitLab que usamos são
instalações em servidoras próprias (do C3SL e do LEG), no entanto, a
interface do usuário é a mesma, com excessão de alguns privilégios
administrativos.

## Habilitar comunição ##

http://www.vogella.com/tutorials/GitHosting/article.html

Geração e configuração das chaves públicas.
Incluir screenshots.

Uma vez criada uma conta, é necessário habilitar a comunicação entre sua
máquina e o (servidor do) GitHub. A comunicação se baseia no protocolo
ssh, o qual já usamos no capítulo anterior para hospedar o repositório
em um servidor remoto.

Para relembrar, a maioria dos servidores suporta a autenticação por SSH
(*secure shell*). Para que seja automática, ou seja, sem precisar
fornecer login e senha a cada acesso, usamos o recurso de pares de
chaves. Este serve para fazer a máquina remota (servidor) reconhecer a
máquina local (sua máquina) por da autenticação do par de chaves. É como
se o servidor fosse um cadeado e a sua máquina local tem a chave que o
abre.

Para gerar as chaves públicas, você precisa executar:
```{r, engine="bash", eval=FALSE}
## Gera chaves públicas.
ssh-keygen -t rsa -C "seu_email@seu.provedor"
```

O endereço padrão para os arquivos criados e o diretório `~/.ssh/`. Os
arquivos serão reescritos caso já existam arquivos de chaves públicas
lá. Toda novo par de chaves é único. Então, se você reescreveu os
arquivos anteriores, terá atualizar as chaves públicas em todos os
serviços web que fazem uso desse recurso e com todos os servidores com o
qual você tem autenticação por chaves.

Acesse <https://github.com/settings/ssh> para então adicionar chaves
públicas (Figura XXX) ao seu perfil. Você precisa estar logado. Clique
em `Add SSH key`, cole o conteúdo copiado do arquivo `*.pub` no campo
`key`. No campo `Title` identifique a máquina correspndente àquela
chave. Use, por exemplo, `laptop` ou `trabalho` para facilitar o
reconhecimento. É comum trabalhar-se com mais de um máquina, como uma em
casa e outra no trabalho.

![](./images/github_sshkeys.png)

FIGURA XXX: *Printscreen* da página de configurações pessoais do
GitHub. No menu `SSH Keys` pode-se ver e adicionar chaves públicas.

Para testar a comunição entre o GitHub e a sua máquina, execute:
```{r, engine="bash", eval=FALSE}
## Testa comunição. Retorna um "Welcome!" em caso positivo.
ssh -T git@github.com

## Se falhar, habilite o modo verbose para rastrear o erro.
ssh -vT git@github.com
```

No GitLab, o cadastro de chaves públicas é um processo semelhante. Uma
vez autenticado, acesse <https://gitlab.c3sl.ufpr.br/profile/keys> para
adicionar chaves públicas.  Para testar a comunição entre o GitHub e a
sua máquina, execute:
```{r, engine="bash", eval=FALSE}
## Testa comunição. Retorna um "Welcome!" em caso positivo.
ssh -T git@gitlab.c3sl.ufpr.br

## Se falhar, habilite o modo verbose para rastrear o erro.
ssh -vT git@gitlab.c3sl.ufpr.br
```

Lembre-se de que o endereço `gitlab.c3sl.ufpr.br` corresponde ao serviço
GitLab disponibilidade pelo C3SL. Caso você esteja fazendo a conta no
GitLab.com, o endereço muda de acordo.

## Gerenciar repositórios ##

**GitHub**

A comunicação com o GitHub acabou de ser estabelecida. Agora podemos
criar repositórios e começar a mostrar nosso trabalho para o mundo e
colaborar de forma eficiente.

No canto superior direito das páginas do GitHub existe um ícone $+$ que
permite criar um novo repositório ou uma nova organização. Clique em
*New repository* ou acesse o endereço <https://github.com/new>. Na
janela que abrir, dê um nome para o seu projeto e adicione uma breve
descrição à ele (Figura XXX). Na etapa seguinte, defina o nível de
visibilidade: público ou privado. Lembre-se que os planos *free* só
permitem repositórios públicos.

![](./images/github_new_repo.png)

FIGURA XXX: Janela para a criação de um novo repositório no GitHub.

Para criar o projeto dentro de uma Organização, selecione a Organização
na *drop list* que fica no no campo Owner, a esquerda do campo para o
nome do repositório.

Você pode inicilizar o repositório com um arquivo `README.md`, o que é
altamente recomendado. Como já mencionamos, esse arquivo é a capa do seu
repositório e serve para documentar o seu objetivo, formas de
colaboração, colaboradores, formas de instalação do software, caso seja
um.

Você pode editar o arquivo `README.md` (ou qualquer outro) no GitHub. As
moficações que fizer devem ser *commitadas* para serem salvas. O arquivo
de `README.md`, que é linguagem de marcação MarkDown, é automaticamente
renderizado pelo GitHub fazendo com que urls sejam clicáveis e códigos
estejam em ambientes de fonto monoespaço, além de ter títulos com
tamanho de fonte apropriado e as demais renderizações.

Depois de criar o repositório, você já pode cloná-lo para trabalhar
localmente. O endereço do repositório é composto pelo seu nome de
usuário e nome do repositório. O repositório `ola-mundo` da conta do
`fulano` pode ser clonado com:

```{r, engine="bash", eval=FALSE}
## Clone pelo protocolo ssh. Requer chaves públicas.
git clone git@github.com:fulano/ola-mundo.git
```

Pode-se clonar repositórios pelo protocolo `http` (*Hypertext Transfer
Protocol*) também. Em geral, para clonar repositórios de outros usuários
e fazer testes, usa-se `http`. Embora você possa usar `http` nos seus
repositórios, prefira o *SSH*. Com `http`, o endereço para a ser:

```{r, engine="bash", eval=FALSE}
git clone https://github.com/fulano/ola-mundo.git
```

Por padrão, ao clonar o repositório, um diretório de mesmo nome é criado
com o projeto em seu interior. Em caso de preferir outro nome para esse
diretório, por exemplo, `OlaMundo`, use:

```{r, engine="bash", eval=FALSE}
git clone https://github.com/fulano/ola-mundo.git OlaMundo
```

Existe outra situação que é quando você já tem repositório Git no qual
já está trabalhando e quer tê-lo no GitHub. Nesse caso, você faz os
mesmos passos, exceto que não irá cloná-lo, apenas adicionar a url do
repositório GitHub ao repositório local e fazer um *push*. Vamos supor
que o repositório seja um artigo científico de nome `Artigo`. Ao criar o
repositório com esse nome no GitHub, o endereço fica
`git@github.com:fulano/Artigo.git`. Então é só adicionar esse endereço
como `origin` do projeto Git:

```{r, engine="bash", eval=FALSE}
## Adiciona endereço de "origin" ao repositório.
git remote add origin git@github.com:fulano/Artigo.git

## Sobe o conteúdo do repositório.
git push -u origin master
```

O seu projeto é configurado em
<https://github.com/walmes/emacs/settings/>.  Para renomear, deletar ou
trasferir o projeto para outro usuário ou organização, vá em
*Options*. Em *Collaborators* você administra os colaboradores do
projeto. Para genrenciar os ramos de trabalho, como proteger ou remover
ramos, vá em *Branches*. O uso de de serviços web é configurado no
*Webhooks & services*. O *Deploy keys* permite adicionar chaves
públicas.

![](./images/github_repo_home.png)

Vamos considerar um repositório de bastante atividade para conhecermos
um pouco mais dos recursos do GitHub. O repositório
<https://github.com/yihui/knitr> é o sítio de desenvolvimento do pacote
`knitr` do R, o principal pacote para a geração de relatórios
dinâmicos. Nesse repositório tem-se acesso aos fontes.

Na figura XXX, logo abaixo do título, tem-se quatro quantificadores:

  * *commits*: ao clinar neste tem-se o histórico de *commits* com
    autor, mensagem e sha1. É possível comparar estados dos arquivos
    (*diff*) ao clinar no sha1.
  * *branches*: este lista os *branches* do projeto, permite comparar
    ramos.
  * *releases*: documenta as modificações de uma versão para outra e
    lista os *commits* que tem *tags*. Essa é uma fonte importate.
  * *contributors*: dá um resumo das atividades dos colaboradores do
    projeto. Na aba *members* tem-se uma lista de todos os usuários que
    fizeram o *fork* do seu projeto. Falaremos de *fork* adiante.

No menu da direita existem links para acessos a mais coisas:

  * code: estão visíveis os diretórios e arquivos do projeto. Pode-se
    navegar entre eles. Ao visualizar um arquivo, ele é renderizado de
    acordo com a linguagem de código que contém para facilitar a
    compreensão. Ao abrir um arquivo, no topo aparecer um botões de
    exibição/ação: *Raw* é para ver o arquivo cru. A url quando estiver
    nessa exibição pode ser usada para carregar arquivos de dados ou
    scripts direto da web. *Blame* mostra o arquivo com autor para cada
    porção do código. O *History* mostra o histórico de *commits*. Os
    dos ícones seguintes permitem editar o arquivo ou deletar.
  * issues: permite criação e acesso aos *issues* do projeto. Dentro
    dessa página tem-se acesso às *Milestones*.
  * pull requests: é o termo que o GitHub usa para requisição de
    mescla. Nesta página pode submeter uma requisição e navegar nas
    existentes.
  * wiki: na Wiki de um repositório normalmente é feita uma documentação
    mais detalhada do projeto. Páginas Wiki de um repositório são também
    repositórios Git, portanto, versionáveis.
  * pulse: dá um resumo sobre s quantidade issues presentes, fechados e
    abertos bem como para requisções de mescla. Mostra também um resumo
    da atividade recente do repositório.
  * graphics: tem-se gráficos sobre a atividade no reporitório, como
    frequência de *commits*, total e por autor, instantes do dia de
    maior colaboração, etc.

Existem ainda mais coisas sobre o GitHub que não podemos deixar de
comentar que são os recursos disníveis para colaboração. Nas sessões à
frente, trataremos do recurso de *fork*, *issue* e requisições de
mescla. Antes, no entanto, vamos conhecer um pouco GitLab, um serviço
web para projetos Git que pode ser instalado no seu servidor.

O GitLab é o serviço que nós do PET usamos para colaboração em nossos
projetos. Além disso, é o que os alunos usam para fazerem seus trabalhos
e desenvolverem o TCC. O uso do Git como ferramenta de trabalho passou
ser estimulado nesse semestre (2015/2).

**GitLab**

Basicamente, o GitLab tem os mesmos recursos, só estão organizados de
forma diferente.

O GitLab concentra os acessos à outras páginas em um meno do lado
esquerdo. Do lado direito pode haver informações extras. O botão para
criar um novo repositório fica no canto superior direit. Ao lado deste
tem botões para ir para página de configurações, sair, ajuda e explorar
o GitLab.

No menu da direita tem-se acesso aos projetos do usuário, ao projetos
favoritos e aos grupos que parcipa. As extradas *Milestones*, *Issues* e
*Merge request* reúnem as informações sobre todos os projetos do qual o
usuário participa.

Assim como acontece com outros serviços web, na página inical do projeto
é exibido o arquivo de capa, o `README.md`. Centralizado na página
encontra-se o endereço para clonar o repositório por SSH ou HTTPS. No
menu da direita estão as principais informações sobre o
projeto. *Project* é a página inicial; *Activity* e *Commits* listam a
atividade (predominantemente *commits*); *Files* apresenta diretórios e
arquivos com opção de mudar o ramo. *Network* o estado de
desenvolvimento dos ramos do projeto com uma lista de todos os
*commits*; *Graphs* contém a atividade de cada membro do
projeto. *Milestones* reúne as marcas de milhas do projeto com progresso
de cada uma e em *Issues* pode-se gerenciar os *issues* dos
projetos. *Merge resquests* permite criação e acompanhamento das
requisições de mescla; *Members* faz a gestão da equipe de trabalho como
adição e redefinição dos níveis de acesso; *Labels* são usados para
classificar os *issues* - é comum usar *bug*, *fix*, *review*. *Wiki*
vai para a página Wiki do repositório, útil para divulgação e
documentação; Finalmente, em *Settings* são feitas as configurações
gerais do projeto como definição de nome, descrição, nível de
visibilidade e adição e *Web Hooks*. Nessa mesma página pode-se
renomear, transferir ou remover o projeto.

Não usamos a conta no <https://gitlab.com/>, usamos a instalação em
servidor próprio disponibilizado pelo c3sl - Centro de Computação
Científica e Software Livre - da UFPR.

# Fluxo de trabalho #

<https://www.atlassian.com/git/>

clone, add, commit, branch, push, fetch, pull.

# Macanísmos de colaboração #

Os serviços web para Git, mesmo que você trabalhe sozinho, já são
interessantes para que você tenha uma cópia (backup) do seu projeto e
disponibilize seu trabalho. No entanto, um dos principais objetivos dos
serviços web é permitir a colaboração entre pessoas. Já mencionamos o
básico sobre isso quando falamos dos recursos de *issue*, *fork* e
*merge request*. Nas sessões a seguir, vamos nos aprofundar nesses três
mecanísmos chaves para a colaboração via serviços web para Git.

## Issues ##

De acordo com o dicionário [Macmillan], *issue* significa um problema
que precisa ser considerado. Também significa um assunto que as pessoas
debatem ou o volume de uma revista. Cabe aqui a primeira definição.

Nos serviços web para Git, *issue* é um recurso da interface que permite
que as pessoas abram um assunto/tópico referente ao projeto. Em geral,
com os *issues* as pessoas externas ao projeto indicam um *bug* - uma
falha a ser corrigida - ou sugerem que o projeto incorpore determinada
característica desejável. O dono do projeto avalia a proposta e pode
discutí-la logo em seguida, mantendo as mensagens reunidas e disponíveis
para outros usuários que acompanham o projeto. Quando a proposta do
*issue* for implementada, o *issue* pode ser fechado embora continua
disponível e possa ser referenciado no, tanto para usuários que
reportarem o problema já solucionado (usuários que não estão usando a
versão mais recente) quanto para incluir no *change log* do projeto
(essa versão corrige o bug descrito no *issue#43*, por exemplo).

Quando um projeto é coletivo, como são a maioria dos projetos no PET
Estatística (<https://gitlab.c3sl.ufpr.br/groups/pet-estatistica>), o
recurso de *issue* pode ser usado de outra forma: como gerenciador de
tarefas. Combinado com as *milestones*, cada membro cria um *issue*
correspondente ao que vai fazer no projeto no período de uma semana. Com
isso, todos os demais membros são notificados de que alguém já vai
trabalhar na tarefa A do projeto, eliminando foco duplicado. O *issue* é
parte do fluxo de trabalho do PET Estatística que será descrito em outro
capítulo.

As *milestones* são uma espécie de coleção de *issues* que tenham algo
em comum. Considere por exemplo o projeto de um livro. As *milestones*
podem ser os capítulos a serem escritos e os *issues* podem ser as
seções. Se for um projeto de software, as *milestones* podem separar os
*issues* referentes ao aperfeiçoamento da documentação do software e ao
desenvolvimento do mesmo (escrita de código fonte).

Criar um issue é muito simples. Tanto no GitHub quanto no GitLab, existe
um fácil acesso as *issues* do projeto. Na página dos *issues* você pode
criar um novo *issue*, comentar em um já existente e até reabrir um
*issue* que já foi fechado (comum quando acredita-se ter resolvido um
*bug* mas que ainda não foi). Os *issues* são numerados sequencialmente
e isso faz com que cada *issue* seja único dentro do projeto. Os
serviços web até tem formas de fazer *hiperlinks* facilmente para os
*issues*. No GitLab, usa-se um hash seguido do número identificador
(e.g. `#45`) para indicar um *issue*.

## Fork ##

A palavra *fork*, como substantivo, representa forquilha,
bifurcação. Como verbo, representa bifurcar. Esse recurso está presente
nas interfaces web para permitir que usuários facam cópias livres de
projetos de outras pessoas. Como essa cópia é do projeto em determinado
instante, há grande chance de divergência entre cópia e original a
partir desse instante, por isso é apropriado a palavra bifurcamento.

As finalidades de um *fork* são duas: 1) ter uma cópia na qual se possa
acrescentar modificações e enviar para o dono e assim contribuir no
projeto original ou 2) usar a cópia como ponto de partida para outro
projeto, sem intenção de voltar ao projeto original.

Com o *fork*, você pode colaborar como um terceiro em um projeto, ou
seja, sem ser colaborador adicionado pelo dono ao projeto. Nessa cópia
você tem permissões de *owner* pois na realidade, embora seja uma cópia,
ela é toda sua. Você faz sua cópia livre, trabalha como quiser e no
prazo que quiser, e submete ao projeto original o desenvido na sua
cópia. O dono do projeto não tem como saber por que você fez o *fork*
(mas você pode criar um *issue*) nem quando irá concluir o que
almeja. No entanto, quando concluir, para que seu trabalho seja
incorporado ao original, você terá que fazer um *merge request* (isso só
é possível entre usuários de um mesmo serviço web).

No GitHub, o acesso ao *fork* é por um botão que fica mais a direita na
linha de título do projeto. No GitLab, o botão de *fork* fica na página
inicial do projeto logo acima do endereço para clonar. Em qualquer um
desses serviços, uma vez logado, ao pedir um *fork*, uma cópia do
projeto é criada no seu perfil.

Uma vez com a cópia, você pode fazer um clone e começar a desenvolver os
projetos. Se a sua intenção é submeter modificações ao original, seja
ainda mais cuidadoso com as mensagens de *issue*. Escreva sempre no
idioma original do projeto. Muitas vezes, antecipando esse tipo de
colaboração, os usuários disponibilizam guias de contribuição
(*contribution guide*) com instruções de como proceder.

Os *branchs* que criar serão na sua cópia os *pushs* que fizer irão para
o seu perfil. Quando o seu trabalho tiver concluído, você pode fazer um
*merge request* que descreveremos a seguir. Se a sua intenção foi usar o
*fork* como semente para um projeto independente, não se esqueça de dar
os devidos créditos ao dono da cópia, mesmo que lá no futuro, o seu
projeto e o original sejam completamente diferentes.

## Merge Request ##

O *merge request* (requisição de mescla/fusão) é o recurso de
colaboração chave. Ele serve para que pessoas da equipe (segundos) peçam
para incorporar *branches* ao ramo principal (em geral o *master* ou o
*devel*) e terceiros peçam para incorporar o desenvolvimento do
*fork*. O GitHub usa o termo *pull request* ao invés de *merge request*
embora não exista diferença alguma.

Os trabalhos coletivos em projetos Git, para serem bem sucedidos,
consideram algum esquema de trabalho. A maioria dos esquemas considera o
desenvolvimento por *branches*. Nada mais justo, já que uma é uma
característica do Git. Existem ramos permanentes, como o
*master*, que recebem os desenvolvimento feito em *branches* auxiliares
ou de demanda. Esses ramos de demanda, como o nome sugere, são criados
para incorporar algo ao projeto e, portanto, não são permanentes - uma
vez incorporados, são removidos.

Nos esquemas de trabalho, os membros são instruídos a fazerem o
desenvolvimentos nos ramos de demandae jamais nos ramos permanentes. Ao
concluir essa unidade de trabalho, esse *branch* é enviado para o
servidor com um `push`

```{r, engine="bash", eval=FALSE}
## Envia o desenvolvido em um ramo.
git push origin issue#33
```

Na interface web, o membro faz um *merge request* desse ramo para um
ramo permamente, que em projetos simples é o *master* mas em projetos
maiores é usualmente o *devel*.

Em ambos os serviços, o *merge resquest* leva para um página na qual
você escolhe que ramo de demanda (doador) será incorporado a um ramo
permamente (receptor). Ao confirmar os ramos envolvidos, tem-se uma
caixa de texto destinada as informações sobre o que as modificações a
serem incorporadas. Elas servem para justificar, esclarecer e informar o
responsável pelo *merge* sobre a incorporação. Quando o projeto é
coletivo e não individual, um membro pode ser indicado como responsável
pelo *merge*.

Na situação de um *fork*, o processo ocorre de forma semelhante. A
sequência de etapas é: fazer o *fork* do projeto para a sua conta, 2)
clonar o projeto para sua máquina, 3) criar um *branch* e fazer o
desenvolvimento nele, 4) subir o *branch* (*push*) para a sua conta e 5)
fazer um *merge request* para incorporar as modificações.

Quando o projeto é um *fork*, na hora de escolher o ramo permanente
(receptor) tem-se duas opções: 1) incorporar ao *master* da sua cópia
ou 2) incorporar ao *master* do original. Outra opção é incorporar ao
*master* da sua cópia e depois pedir um *merge request* do seu *master*
para o *master* do original. Essa última é útil quando a quantidade de
modificações é maior e portanto, o trabalho vai levar mais tempo.

O próprio serviço Web tem recurso para a apliação do *merge* sem
precisar copiar os ramos envolvidos. Isso facilita bastante o
trabalho. Porém, não haver conflito de *merge* não significa que as
modificações incorparadas estão funcionais, ou seja, as modificações
feitas precisam ser testadas localmente para verificar de tiveram
efeito. É possível habilitar o serviço Git para checar se o projeto é
executável, em caso de softwares. Esse recurso se chama intergração
contínua e veremos na próxima sessão.

Em caso de confito de *merge*, tem-se baixar os ramos. Localmente
pode-se comparar as diferenças entre eles para entender as fontes de
conflito. Para isso são recomendáveis as interfaces para Git que serão
discutidas no próximo Capítulo. Uma vez que o *merge* foi resolvido,
deve-se fazer o *push* o ramo permanente (receptor) para o serviço web
que já reconheçe que o *merge* foi feito e fecha a requisição.

Recomenda-se que os ramos de demanda sejam removidos após a incorporação
nos ramos permanentes. Isso torna o projeto mais claro e concentrado em
ramos definitivos colhedores de desenvolvimento. Pode-se exluir o ramo
de demanda incorporado direto pela interface. Por linha de comando
também é possível

```{r, engine="bash", eval=FALSE}
## Deleta o branch issue#33 no servidor (origin).
git push origin :issue#33

## Deleta o branch issue#33 localmente.
git branch -d issue#33

## Deleta a cópia do issue#33 que veio do origin.
git branch -dr origin/issue#33
```

Ao concluir incorporar uma contribuição grande, é interessante marcar o
*commit* vinculado à esse *merge* de uma forma destacável, como por
exemplo, com uma *tag*.

```{r, engine="bash", eval=FALSE}
## Lista as tags existentes.
git tag

## Adiciona uma tag ao último commit.
git tag -a v1.0 -m "Versão 1.0 do software"
```

# Integração contínua #

Quando você está trabalhando em um projeto Git, cada *commit*, cada
*branch*, contém algum desenvolvimento. Solucionar conflitos de *merge*
não é um atarefa complicada, principalmente se forem consideradas as
ferramentas certas para isso, como será visto no próximo capítulo. No
entanto, para cada *commit* tem-se a preocupação: será que o projeto
está funcional?

Reprodutibilidade é uma questão de fundamental importância em projetos
coletivos ou públicos. Existe a preocupação constante de que seu código
(programa) seja executado (instalado) sem erros nos ambientes dos seus
colaboradores ou usuários. É claro que o desenvolvimento do projeto visa
aperfeiçoá-lo mas o tempo todo estamos sujeitos fazer modificações que
induzem erros e alguém encontra erros não esperados (*bugs*).

Monitorar erros no projeto em desenvolvimento não é uma tarefa fácil,
principalmente em trabalhos coletivos nos quais cada colaborator tem um
ambiente de trabalho. Em uma situação ideal, alguém teria que testar se
o projeto corre sem erros (código executa, software instala) em uma
máquina cliente (com os requisitos mínimos exigidos), toda vez que um
*commit* fosse feito, já que o *commit* indica que modificações foram
feitas. Então, se correu sem erros, avisar à todos que podem prosseguir,
mas se falhou, informar a equipe, encontrar e resolver a falha.

Não é raro algo ser bem sucedido no ambiente em que foi desenvolvido e
apresentar falhas na ambiente de outra pessoa. O melhor jeito de
antecipar erros é testar em um ambiente virgem, uma máquina cliente que
contenha apenas os requisitos mínimos necessários ao projeto.

A Integração Contínua (IC) é a solução desse problema. A ideia é manter
o repositório Git continuamente integrado à um ambiente cliente que faz
verificações no projeto a cada novo *push*.

Fazer integração contínua no GitHub e GitLab, embora o conceito seja o
mesmo, tem algumas diferenças. Paro o GitHub existem diversos serviços
de IC, é algo terceirizado. Já o GitLab CE têm o serviço próprio de
IC desde a versão 8.0. Apresentaremos cada um deles na sessão seguinte.

Independe do serviço web, as vantagens da IC são:

  1) Economia de tempo com supervisão de código e procura de falhas;
  2) Verificação em um ambiente virgem sem efeito de variáveis de
     ambiente locais;
  3) Verificação em vários ambientes (sistemas operacionais,
     arquiteturas, dependências e versões);
  4) Informação coletiva e imediata à equipe da causa de falha na hora
     que ela ocorre;
  5) Indicação de sucesso ou não na home do projeto;
  6) Entrega de versões estáveis, documentação e arquivos acessórios com
     *continuous deployment*.
  7) Custo computacional reduzido já que é feito em um servidor
     dedicado.
  8) Verificação a cada *push* feito.
  9) Status exibido para cada branch e requisição de merge.
  10) Aumenta a visilibidade facilitanto a comunicação e reunião de
      esforços.
  12) Menos tempo na correção de bug, que devem ser menores, assim
      deixando mais tempo para desenvolver o que interessa.
  13) É barato, até mesmo quando custa algo, porque parar o projeto por
      erro pode custar inclusive mais caro.
  14) Reduz os problemas com usuários fora dos colaboradores pois testa
      em máquinas virgens.
  15) Facilita para os usuários saberem se a última versão é executável.
  16) Pode automatizar a disponibilização do projeto aos usuários.

A integração contínua não elinima erros, mas faz com que eles sejam mais
fáceis de identificar e remover.

Sem a automação, os espaços entre verificações podem ficar longos,
encontrar um bug em tantos commits é mais difícil, encontrar no código é
mais ainda. Pode atrasar a entrega do projeto e comprometer a receita e
popularidade. Integrações periodicas são mais fáceis e leves.

O build é automático, faz um self-testing a cada commit.

O fluxo de trabalho de um repositório com IC é basicamente assim:

  1) Os desenvolvedores trabalham no projeto em seu workspace
     privado/local;
  2) Periodicamente fazem *commits* e *push* para o repositório remoto;
  3) O serviço de IC monitora o repositório toda vez que modificações
     ocorrem;
  4) O serviço de IC corre todos os testes de inspeção que foram
     configurados (instala dependendencias, executa scripts,
     cria/tranfere arquivos, etc);
  5) O serviço de IC disponibiliza produtos da verificação, como
     binários de instalação e documentação (no caso de sucesso) ou log
     de execussão (no caso de falha);
  6) O serviço de IC assinalá no repositório Git o *status* da
     verificação: sucesso/fracasso;
  7) O serviço de IC informa a equipe dos resultados por mensagem de
     email ou webhooks, como o Slack;
  8) A equipe toma das providências cabiveis na primeira oportunidade,
     como corrigir a falha ou anunciar o sucesso;
  9) O serviço aguarda por mais modificações;
  
**GitHub**

https://travis-ci.org/
http://www.codeaffine.com/2014/09/01/travis-continuous-integration-for-github-projects/

Embora exista uma lista grande de serviços de integração contínua
disponíveis para repositórios GitHub, um dos mais usados é o Travis CI.
Travis CI (*continuous integration*) é um serviço free e open source
destinado à integração contínua para projeto **públicos** no GitHub.

Para vincular um projeto no GitHub com IC no Travis CI, você precisa
logar no <https://travis-ci.org/> com a sua conta do GitHub. Assim que
você logar, o serviço pede autorização para acessar sua conta, seus
repositórios. Acesso permitido, uma lista com os seus repositórios será
exibida na qual você pode marcar os repositórios que usarão o serviço.
A próxima etapa é criar um arquivo `.travis.yml` na raíz do seu
repositório Git. Esse arquivo espefica todas as instruções sobre o seu
repostório de devem ser feitas a fim de verificá-lo. Se seu repositório
é um pacote R, por exemplo, esse arquivo vai ter instruções de
instalação do pacote.

Cada projeto, cada linguagem, têm uma forma particular de ser
testada. Para pacotes R, o Travis CI tem uma documentação de orientação:
<https://docs.travis-ci.com/user/languages/r/>. Além disso, uma boa
prática em ver exemplos em uso, como o `.travis.yml` dos pacotes R
`knitr` (<https://github.com/yihui/knitr>) e `devtools`
(<https://github.com/hadley/devtools>) que estão na lista dos mais
utilizados.

Para todas as liguagens e objetivos têm-se exemplos de arquivos
`.trevis.yml`. Para o Emacs e biblitecas visite
<https://github.com/rolandwalker/emacs-travis>,
<https://github.com/Malabarba/elisp-bug-hunter> e
<https://github.com/abo-abo/tiny>. Para projetos em `C++` e `phyton`,
assim como o R, o Travis CI tem uma documentação introdutória. Visite
<https://docs.travis-ci.com/user/language-specific/> para ver a lista de
documentações.

Além do linguagens de programação, é possível testar inclusive a
compilação de um documento Latex:
<http://harshjv.github.io/blog/setup-latex-pdf-build-using-travis-ci/>.

*branch build flow*
*pull request build flow*

`after_failure` (information, error report)
`after_success` (deployment, uploads de documentação e versões estáveis)

exibir build status no README
fazer *webhook* com Slack

**GitLab**

GitLab.com + servidor no digital ocean.
http://alanmonger.co.uk/php/continuous/integration/gitlab/ci/docker/2015/08/13/continuous-integration-with-gitlab-ci.html

Integração contínua passou fazer parte do GitLab CE na versão 8.0,
lançada em 22/09/2015. O GitLab do LEG já faz uso dessa última versão.
<https://about.gitlab.com/2015/09/22/gitlab-8-0-released/>

As especificação são feitas em um arquivo `.gitlab-ci.yml` na home do
projeto.

```{r, eval=FALSE, engine="sh"}
job_R:
  script:
    - echo $HOME
    - Rscript -e 'getwd(); .libPaths(); sessionInfo()'
    - Rscript -e 'library(devtools); check()'
    - Rscript -e 'library(devtools); .libPaths(new = path.expand("~/R-tests/legTools")); install(local = FALSE)'
```

https://about.gitlab.com/gitlab-ci/
https://about.gitlab.com/2015/02/03/7-reasons-why-you-should-be-using-ci/

<https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software>

<!---------------------------------------------------------------------- -->

[Klint Finley]: http://techcrunch.com/2012/07/14/what-exactly-is-github-anyway/
[GitLab]: https://about.gitlab.com/
[GitHub]: https://github.com/
[GitHub Interprise]: https://enterprise.github.com

[^1]: http://technologyconversations.com/2015/10/16/github-vs-gitlabs-vs-bitbucket-server-formerly-stash/
[Digital Ocean]: https://www.digitalocean.com/community/tutorials/how-to-use-the-gitlab-one-click-install-image-to-manage-git-repositories
[GitLab]: https://about.gitlab.com/
[Macmillan]: http://www.macmillandictionary.com
